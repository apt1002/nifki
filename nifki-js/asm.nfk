# A maze game.
 FALSE LSTORE(showDemos) ;
#showDemos = TRUE
 #mapOrder = "ABCDEFGHIJKLMN" # official
 #mapOrder = "INABCDEFGHJLM" # fiddling
 "GH" LSTORE(mapOrder) ;
# cheating
 TABLE LSTORE(maps) ;
LLOAD(maps) "A" TABLE 0 "<>###<>" PUT 1 "><+++><" PUT 2 "#+++++#" PUT 3 "#++A++#" PUT 4 "#+++++#" PUT 5 "<>+++<>" PUT 6 "><###><" PUT PUT LSTORE(maps) ;
LLOAD(maps) "B" TABLE 0 "##########" PUT 1 "#AO  O  +#" PUT 2 "#### #> +#" PUT 3 "   #######" PUT PUT LSTORE(maps) ;
LLOAD(maps) "C" TABLE 0 "  ###  " PUT 1 "###+###" PUT 2 "#::O::#" PUT 3 "#:#+#:#" PUT 4 "#   A #" PUT 5 "#######" PUT PUT LSTORE(maps) ;
LLOAD(maps) "D" TABLE 0 "<>###<>" PUT 1 "><OOO><" PUT 2 "#O+++O#" PUT 3 "#O+A+O#" PUT 4 "#O+++O#" PUT 5 "<>+++<>" PUT 6 "><###><" PUT PUT LSTORE(maps) ;
LLOAD(maps) "E" TABLE 0 "#######" PUT 1 "#+#+#+#" PUT 2 "#AOOOO#" PUT 3 "#+++++#" PUT 4 "#######" PUT PUT LSTORE(maps) ;
LLOAD(maps) "F" TABLE 0 "#########" PUT 1 "#+::A::+#" PUT 2 "##:O#O:##" PUT 3 "#::<+O::#" PUT 4 "#:#::<#:#" PUT 5 "#:+#::::#" PUT 6 "#########" PUT PUT LSTORE(maps) ;
LLOAD(maps) "G" TABLE 0 "   #######" PUT 1 "   #   OA<" PUT 2 "   #::O+<" PUT 3 "#### O+<" PUT 4 "#   O+<" PUT 5 "#++++<" PUT 6 "####<" PUT PUT LSTORE(maps) ;
LLOAD(maps) "H" TABLE 0 "#######" PUT 1 "#+OOO+#" PUT 2 "##>O<##" PUT 3 "#O+++##" PUT 4 "#O#++ #" PUT 5 "#+# > #" PUT 6 "#  A  #" PUT 7 "#######" PUT PUT LSTORE(maps) ;
LLOAD(maps) "I" TABLE 0 "######" PUT 1 "#++++#" PUT 2 "#+OO+#" PUT 3 "#++++#" PUT 4 "#O+AO#" PUT 5 "#++++#" PUT 6 "#+OO+#" PUT 7 "#++++#" PUT 8 "######" PUT PUT LSTORE(maps) ;
LLOAD(maps) "J" TABLE 0 "##########" PUT 1 "#++OOO+++#" PUT 2 "#OO+OO+OO#" PUT 3 "#+O+++#++#" PUT 4 "#+A++O#++#" PUT 5 "#++O+++++#" PUT 6 "##########" PUT PUT LSTORE(maps) ;
LLOAD(maps) "K" TABLE 0 " ### " PUT 1 "##O##" PUT 2 "# A:#" PUT 3 "## ##" PUT 4 " #+# " PUT 5 " ### " PUT PUT LSTORE(maps) ;
LLOAD(maps) "L" TABLE 0 "################" PUT 1 "#AOO: O:O :OO+O#" PUT 2 "#+:#<>+<>+<>+O+#" PUT 3 "#+#+OO>OO>OO>+O#" PUT 4 "#+#OO<O++#++#O+#" PUT 5 "#+#O< + +#++#+O#" PUT 6 "#+#O#:+:<:++#O+#" PUT 7 "#+#+ >:<>##:#+O#" PUT 8 "#+#:#   O O:#O+#" PUT 9 "#+#:#::O:<O>O+O#" PUT 10 "#+#:> O:<OOO>O+#" PUT 11 "#+#::>:<+:++#+O#" PUT 12 "#+>::::+#:++#O+#" PUT 13 "#+:>##:#O##:<+O#" PUT 14 "#::::::::::::::#" PUT 15 "################" PUT PUT LSTORE(maps) ;
LLOAD(maps) "M" TABLE 0 "##############" PUT 1 "#+O#OOOO+OOO+#" PUT 2 "##O#O>++:::+ #" PUT 3 "#AOOO## O  # #" PUT 4 "# #>O+O#O# # #" PUT 5 "#  O>++#+ #OO#" PUT 6 "#+ : ++ :#O++#" PUT 7 "#+>#### # O  #" PUT 8 "#+ O#+#   #  #" PUT 9 "#+ : O ## OOO#" PUT 10 "#+># #  O+::+#" PUT 11 "#+O#   OOOOOO#" PUT 12 "#+:#+++++++++#" PUT 13 "##+###########" PUT PUT LSTORE(maps) ;
LLOAD(maps) "N" TABLE 0 "#########" PUT 1 "#OO+++++#" PUT 2 "#OO+OOOO#" PUT 3 "#OOOOOOO#" PUT 4 "#OOOOOOO#" PUT 5 "#OOOOOOO#" PUT 6 "#OOOOOOO#" PUT 7 "#OOOOOOO#" PUT 8 "#OOOOOOO#" PUT 9 "#OOO+OOO#" PUT 10 "#OO+++OO#" PUT 11 "#OOA+++O#" PUT 12 "#O+  #+O#" PUT 13 "#O++   O#" PUT 14 "#O++:+OO#" PUT 15 "#O+#  +O#" PUT 16 "#O   ++O#" PUT 17 "#OO+:++O#" PUT 18 "#O+  #+O#" PUT 19 "#O++   O#" PUT 20 "#+++:+++#" PUT 21 "#       #" PUT 22 "#########" PUT PUT LSTORE(maps) ;
# Feel free to add new levels here.
 TABLE LSTORE(demos) ;
# Give each map an empty demo.
 LLOAD(maps) FOR DROP LSTORE(mapName) ;
LLOAD(demos) LLOAD(mapName) "" PUT LSTORE(demos) ;
NEXT ;
ELSE ;
LLOAD(showDemos) IF ;
# I'm afraid you have to insert waits for rockfalls manually at the moment.
 LLOAD(demos) "A" "URDDLLUUURRDRDDDDLDLLULUU" PUT LSTORE(demos) ;
LLOAD(demos) "B" "RRRRRRRD" PUT LSTORE(demos) ;
LLOAD(demos) "C" "RRRUULRDDLLLLUURRUDD" PUT LSTORE(demos) ;
LLOAD(demos) "D" "DDRLLURRULLURR" PUT LSTORE(demos) ;
LLOAD(demos) "E" "DUUDRDULRRDUUDRDULRRDUU" PUT LSTORE(demos) ;
LLOAD(demos) "F" "RRRLDDRDDLLLUUDL-RURUULLLLRDDLDDR" PUT LSTORE(demos) ;
LLOAD(demos) "G" "LDULLDRDLDLLLDLRRR" PUT LSTORE(demos) ;
LLOAD(demos) "H" "RRUULULL-------RUURRLLLLRRDDDRLDDLLLU" PUT LSTORE(demos) ;
LLOAD(demos) "I" "DLLRURRDLRDDLLL-UUUUUURRRDDLL" PUT LSTORE(demos) ;
LLOAD(demos) "J" "RRDRRRRUUL--RUULLDRDDDLLUULL--UULLDDRLDDR" PUT LSTORE(demos) ;
LLOAD(demos) "K" "RLDD" PUT LSTORE(demos) ;
LLOAD(demos) "L" "DRLDDDDDDDDDDDDRRRRRUURLDDRRRRRRRRLURULURULURULURULURULUR" "ULURDLLURLLLLDURLLLLDURLLLLLLDDDDDDDDDDDDRRRDRRRRRRRRRUULLR" + "RULLLLLLRRUUURUULLRUUR--LURDDDLRDDLLLDULLDRDLDUUUUUURLRRULL" + "DDDDDDDDLLULDUUUUUR-------------LUUUU" + PUT LSTORE(demos) ;
LLOAD(demos) "M" "DDRDRRRRRDDRRDDLRUUURLRURR-LURUUULLR-LDLLURRRRDDDLDLDLDLL" "UULULDRLUUDRDLRRRUR-LUUUURLLDRULLDRULLLDDLLLDDDDDRDRRDDDRUL" + "RRDLURRDLURRDLURRDLURRDRRLURULLLLLLULUDRDRRRRURUUUURUUUULLL" + "LLLLLDDLLLRUULRDDLDDDDDDDDDRD" + PUT LSTORE(demos) ;
LLOAD(demos) "N" "DRDRDDLDLDDRDRDRRLUUDLDLLLLRURLURUULUDRDRRRULRULU" "URUDLDLLLURLURURRRLULLRULUUUU" + "UUUURRRR" + PUT LSTORE(demos) ;
THEN ;
ELSE ;
LOOP ;
TRUE WHILE ;
LLOAD(mapOrder) FOR LSTORE(mapName) DROP ;
LOAD(Rocks_playUntilWin) TABLE 0 LLOAD(maps) LLOAD(mapName) GET PUT "demo" LLOAD(demos) LLOAD(mapName) GET PUT CALL DROPTABLE ;
NEXT ;
ELSE ;
LOOP ;
KEYS "Space" GET WHILE ;
WAIT ;
NEXT ;
ELSE ;
CLS ;
WINDOW LSTORE(TEMP) ;
LLOAD(TEMP) 31.0 SET(W) LLOAD(TEMP) 31.0 SET(H) ;
WINDOW LSTORE(TEMP) ;
LLOAD(TEMP) 2.0 NEG SET(X) ;
LLOAD(TEMP) 13.0 NEG SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
TABLE 0 "+   + + +  + +  + ++++ +++ " PUT 1 "+   + + ++ + ++ + +    +  +" PUT 2 "+ + + + + ++ + ++ +++  +++ " PUT 3 "++ ++ + +  + +  + +    +  +" PUT 4 "+   + + +  + +  + ++++ +  +" PUT FOR LSTORE(row) LSTORE(y) ;
LLOAD(row) FOR LSTORE(cell) LSTORE(x) ;
LLOAD(cell) "+" == IF ;
LOAD(Rocks_wallPNG) SPRITE LSTORE(TEMP) LLOAD(TEMP) 1.0 SET(W) LLOAD(TEMP) 1.0 SET(H) LLOAD(TEMP) LSTORE(TEMP) ;
LLOAD(TEMP) LLOAD(x) SET(X) ;
LLOAD(TEMP) LLOAD(y) SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
THEN ;
ELSE ;
NEXT ;
ELSE ;
NEXT ;
ELSE ;
LOOP ;
KEYS "Space" GET NOT WHILE ;
WAIT ;
NEXT ;
ELSE ;
CLS ;
# Throw away all the demos so people can actually play.
 LLOAD(maps) FOR DROP LSTORE(mapName) ;
LLOAD(demos) LLOAD(mapName) "" PUT LSTORE(demos) ;
NEXT ;
ELSE ;
BREAK NEXT ;
ELSE ;
# Plays the same level repeatedly until the player solves it.
 # Plays a single level, displays a success or failure screen, and returns TRUE
 # for success and FALSE for failure.
 # Move all the falling rocks.
 # Returns 'TRUE' if the man dies, otherwise 'FALSE'.
 # Define some useful tests.
 # Runs a little celebration animation.
 DEF(Rocks_isRight) LSTORE(ARGS) ;
LLOAD(ARGS) 0 GET LSTORE(pic) ;
LLOAD(pic) LOAD(Rocks_diamondPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
LLOAD(pic) LOAD(Rocks_rockPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
LLOAD(pic) LOAD(Rocks_rightPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
FALSE RETURN DEF(Rocks_moveRocks) LSTORE(ARGS) ;
LLOAD(ARGS) 0 GET LSTORE(manX) ;
LLOAD(ARGS) 1 GET LSTORE(manY) ;
LLOAD(ARGS) 2 GET LSTORE(dx) ;
LLOAD(ARGS) 3 GET LSTORE(dy) ;
LLOAD(ARGS) 4 GET LSTORE(bgSprites) ;
# This array of flags is used to ensure rocks only move once each frame.
 TABLE LSTORE(isMoving) ;
LLOAD(bgSprites) 0.0 GET FOR DROP LSTORE(x) ;
LLOAD(isMoving) LLOAD(x) FALSE PUT LSTORE(isMoving) ;
NEXT ;
ELSE ;
# Scan for rocks.
 LLOAD(bgSprites) FOR LSTORE(row) LSTORE(y) ;
LLOAD(row) FOR LSTORE(rockSprite) LSTORE(x) ;
LLOAD(rockSprite) "Picture" GET LOAD(Rocks_rockPNG) == IF ;
LLOAD(isMoving) LLOAD(x) GET IF ;
LLOAD(isMoving) LLOAD(x) FALSE PUT LSTORE(isMoving) ;
THEN ;
LLOAD(bgSprites) LLOAD(y) 1.0 + GET LSTORE(rowBelow) ;
LLOAD(rowBelow) LLOAD(x) GET LSTORE(belowSprite) ;
TABLE LSTORE(dests) ;
LLOAD(dests) LLOAD(x) TRUE PUT LSTORE(dests) ;
LLOAD(belowSprite) "Picture" GET LSTORE(below) ;
LOAD(Rocks_isLeft) TABLE 0 LLOAD(below) PUT CALL LLOAD(row) LLOAD(x) 1.0 - GET "Picture" GET LOAD(Rocks_blankPNG) == AND IF ;
# It could fall left.
 LLOAD(dests) LLOAD(x) 1.0 - TRUE PUT LSTORE(dests) ;
THEN ;
ELSE ;
LOAD(Rocks_isRight) TABLE 0 LLOAD(below) PUT CALL LLOAD(row) LLOAD(x) 1.0 + GET "Picture" GET LOAD(Rocks_blankPNG) == AND IF ;
# It could fall right.
 LLOAD(dests) LLOAD(x) 1.0 + TRUE PUT LSTORE(dests) ;
THEN ;
ELSE ;
LLOAD(dests) FOR DROP LSTORE(destX) ;
# Is there anything in the way?
 LLOAD(rowBelow) LLOAD(destX) GET LSTORE(destSprite) ;
# IF moving into a blank AND the man is not in the way
 LLOAD(destSprite) "Picture" GET LOAD(Rocks_blankPNG) == LLOAD(destX) LLOAD(manX) LLOAD(dx) - != LLOAD(destX) LLOAD(manX) != AND LLOAD(y) 1.0 + LLOAD(manY) LLOAD(dy) - != LLOAD(y) 1.0 + LLOAD(manY) != AND LLOAD(y) LLOAD(manY) LLOAD(dy) - != AND LLOAD(y) LLOAD(manY) != AND OR AND IF ;
# Move the rock.
 LLOAD(rockSprite) LOAD(Rocks_blankPNG) SET(Picture) LLOAD(destSprite) LOAD(Rocks_rockPNG) SET(Picture) LLOAD(isMoving) LLOAD(destX) TRUE PUT LSTORE(isMoving) ;
# Does it squash the man?
 LLOAD(destX) LLOAD(manX) LLOAD(dx) - == LLOAD(y) 2.0 + LLOAD(manY) LLOAD(dy) - == AND IF ;
TRUE RETURN THEN ;
ELSE ;
# Don't consider any other destination for this rock.
 BREAK THEN ;
ELSE ;
NEXT ;
ELSE ;
ELSE ;
THEN ;
ELSE ;
NEXT ;
ELSE ;
NEXT ;
ELSE ;
FALSE RETURN DEF(Rocks_celebrate) LSTORE(ARGS) ;
LLOAD(ARGS) 0 GET LSTORE(picture) ;
WINDOW LSTORE(TEMP) ;
LLOAD(TEMP) 0.0 SET(X) ;
LLOAD(TEMP) 0.0 SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
TABLE LSTORE(sparks) ;
100.0 FOR DROP LSTORE(count) ;
LLOAD(sparks) LLOAD(count) TABLE "x" WINDOW "W" GET 2.0 / 0.5 - PUT "y" WINDOW "H" GET 2.0 / 0.5 - PUT "dx" RANDOM 0.5 - 1.0 * PUT "dy" RANDOM 0.5 - 1.0 * PUT "sprite" LLOAD(picture) SPRITE LSTORE(TEMP) LLOAD(TEMP) 1.0 SET(W) LLOAD(TEMP) 1.0 SET(H) LLOAD(TEMP) PUT PUT LSTORE(sparks) ;
NEXT ;
ELSE ;
LOOP ;
KEYS "Space" GET NOT WHILE ;
LLOAD(count) 1.0 + 100.0 % LSTORE(count) ;
LLOAD(sparks) LLOAD(count) GET "sprite" GET FALSE SET(IsVisible) ;
LLOAD(sparks) LLOAD(count) TABLE "x" WINDOW "W" GET 2.0 / 0.5 - PUT "y" WINDOW "H" GET 2.0 / 0.5 - PUT "dx" RANDOM 0.5 - 1.0 * PUT "dy" RANDOM 0.5 - 1.0 * PUT "sprite" LLOAD(picture) SPRITE LSTORE(TEMP) LLOAD(TEMP) 1.0 SET(W) LLOAD(TEMP) 1.0 SET(H) LLOAD(TEMP) PUT PUT LSTORE(sparks) ;
LLOAD(sparks) FOR LSTORE(spark) LSTORE(i) ;
LLOAD(spark) "x" LLOAD(spark) "x" GET LLOAD(spark) "dx" GET + PUT LSTORE(spark) ;
LLOAD(spark) "y" LLOAD(spark) "y" GET LLOAD(spark) "dy" GET + PUT LSTORE(spark) ;
LLOAD(spark) "dy" LLOAD(spark) "dy" GET 0.01 + PUT LSTORE(spark) ;
LLOAD(spark) "sprite" GET LSTORE(TEMP) ;
LLOAD(TEMP) LLOAD(spark) "x" GET SET(X) ;
LLOAD(TEMP) LLOAD(spark) "y" GET SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
LLOAD(sparks) LLOAD(i) LLOAD(spark) PUT LSTORE(sparks) ;
NEXT ;
ELSE ;
WAIT ;
NEXT ;
ELSE ;
CLS ;
TABLE RETURN DEF(Rocks_isLeft) LSTORE(ARGS) ;
LLOAD(ARGS) 0 GET LSTORE(pic) ;
LLOAD(pic) LOAD(Rocks_diamondPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
LLOAD(pic) LOAD(Rocks_rockPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
LLOAD(pic) LOAD(Rocks_leftPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
FALSE RETURN DEF(Rocks_playUntilWin) LSTORE(ARGS) ;
LLOAD(ARGS) 0 GET LSTORE(map) ;
LLOAD(ARGS) "demo" CONTAINS IF ;
LLOAD(ARGS) "demo" GET LSTORE(demo) ;
THEN ;
"" LSTORE(demo) ;
ELSE ;
LOOP ;
LOAD(Rocks_playLevel) TABLE 0 LLOAD(map) PUT "demo" LLOAD(demo) PUT CALL NOT WHILE ;
NEXT ;
ELSE ;
TABLE RETURN DEF(Rocks_isWall) LSTORE(ARGS) ;
LLOAD(ARGS) 0 GET LSTORE(pic) ;
LLOAD(pic) LOAD(Rocks_wallPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
LLOAD(pic) LOAD(Rocks_leftPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
LLOAD(pic) LOAD(Rocks_rightPNG) == IF ;
TRUE RETURN THEN ;
ELSE ;
FALSE RETURN DEF(Rocks_playLevel) LSTORE(ARGS) ;
LLOAD(ARGS) 0 GET LSTORE(map) ;
LLOAD(ARGS) "demo" CONTAINS IF ;
LLOAD(ARGS) "demo" GET LSTORE(demo) ;
THEN ;
"" LSTORE(demo) ;
ELSE ;
WINDOW LSTORE(TEMP) ;
LLOAD(TEMP) 12.0 SET(W) LLOAD(TEMP) 12.0 SET(H) ;
# Define the mapping of characters to pictures.
 TABLE LSTORE(pictures) ;
LLOAD(pictures) " " LOAD(Rocks_blankPNG) PUT LSTORE(pictures) ;
LLOAD(pictures) "A" LOAD(Rocks_blankPNG) PUT LSTORE(pictures) ;
# This marks the start position.
 LLOAD(pictures) ":" LOAD(Rocks_earthPNG) PUT LSTORE(pictures) ;
LLOAD(pictures) "+" LOAD(Rocks_diamondPNG) PUT LSTORE(pictures) ;
LLOAD(pictures) "O" LOAD(Rocks_rockPNG) PUT LSTORE(pictures) ;
LLOAD(pictures) "#" LOAD(Rocks_wallPNG) PUT LSTORE(pictures) ;
LLOAD(pictures) "<" LOAD(Rocks_leftPNG) PUT LSTORE(pictures) ;
LLOAD(pictures) ">" LOAD(Rocks_rightPNG) PUT LSTORE(pictures) ;
# Construct sprites for the map, count diamonds, and find the start position.
 TABLE LSTORE(bgSprites) ;
0.0 LSTORE(numDiamonds) ;
LLOAD(map) FOR LSTORE(row) LSTORE(y) ;
LLOAD(bgSprites) LLOAD(y) TABLE PUT LSTORE(bgSprites) ;
LLOAD(row) FOR LSTORE(char) LSTORE(x) ;
LLOAD(pictures) LLOAD(char) GET SPRITE LSTORE(TEMP) LLOAD(TEMP) 1.0 SET(W) LLOAD(TEMP) 1.0 SET(H) LLOAD(TEMP) LSTORE(sprite) ;
LLOAD(sprite) LSTORE(TEMP) ;
LLOAD(TEMP) LLOAD(x) SET(X) ;
LLOAD(TEMP) LLOAD(y) SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
LLOAD(bgSprites) LLOAD(y) DGET LLOAD(x) LLOAD(sprite) PUT PUT LSTORE(bgSprites) ;
LLOAD(char) "A" == IF ;
LLOAD(x) LSTORE(manX) ;
LLOAD(y) LSTORE(manY) ;
THEN ;
LLOAD(char) "+" == IF ;
LLOAD(numDiamonds) 1.0 + LSTORE(numDiamonds) ;
THEN ;
ELSE ;
ELSE ;
NEXT ;
ELSE ;
NEXT ;
ELSE ;
LLOAD(numDiamonds) DUMP ;
" diamonds to collect\A/" DUMP ;
LLOAD(demo) "" != IF ;
"Playing demo: '" DUMP ;
LLOAD(demo) DUMP ;
"'\A/" DUMP ;
THEN ;
ELSE ;
# Construct a sprite for the man.
 LOAD(Rocks_manPNG) SPRITE LSTORE(TEMP) LLOAD(TEMP) 1.0 SET(W) LLOAD(TEMP) 1.0 SET(H) LLOAD(TEMP) LSTORE(man) ;
# Game loop.
 0.0 LSTORE(dx) ;
0.0 LSTORE(dy) ;
0.0 LSTORE(manCount) ;
0.0 LSTORE(bgCount) ;
FALSE LSTORE(manDead) ;
0.0 LSTORE(demoPos) ;
# Position within the 'demo' string.
 "" LSTORE(moves) ;
# Moves made so far. This is printed at the end of the level.
 LOOP ;
LLOAD(numDiamonds) 0.0 > LLOAD(manDead) NOT AND WHILE ;
# Display a frame.
 LLOAD(man) LSTORE(TEMP) ;
LLOAD(TEMP) LLOAD(manX) LLOAD(dx) LLOAD(manCount) * - SET(X) ;
LLOAD(TEMP) LLOAD(manY) LLOAD(dy) LLOAD(manCount) * - SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
WINDOW LSTORE(TEMP) ;
LLOAD(TEMP) LLOAD(man) "X" GET 0.5 + WINDOW "W" GET 2.0 / - SET(X) ;
LLOAD(TEMP) LLOAD(man) "Y" GET 0.5 + WINDOW "H" GET 2.0 / - SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
WINDOW LLOAD(bgCount) 0.05 * SET(B) WAIT ;
# Read the demo or the keyboard, if the man is exactly in a square.
 LLOAD(manCount) 0.0 == IF ;
LLOAD(demoPos) LLOAD(demo) LEN < IF ;
# Get the next move from the demo sequence.
 LLOAD(demo) LLOAD(demoPos) GET LSTORE(key) ;
LLOAD(demoPos) 1.0 + LSTORE(demoPos) ;
LLOAD(key) "L" == IF ;
1.0 NEG LSTORE(dx) ;
THEN ;
ELSE ;
LLOAD(key) "R" == IF ;
1.0 LSTORE(dx) ;
THEN ;
ELSE ;
LLOAD(key) "U" == IF ;
1.0 NEG LSTORE(dy) ;
THEN ;
ELSE ;
LLOAD(key) "D" == IF ;
1.0 LSTORE(dy) ;
THEN ;
ELSE ;
THEN ;
# Get the next move by reading the keyboard.
 KEYS "LeftArrow" GET IF ;
LLOAD(dx) 1.0 - LSTORE(dx) ;
THEN ;
ELSE ;
KEYS "RightArrow" GET IF ;
LLOAD(dx) 1.0 + LSTORE(dx) ;
THEN ;
ELSE ;
KEYS "UpArrow" GET IF ;
LLOAD(dy) 1.0 - LSTORE(dy) ;
THEN ;
ELSE ;
KEYS "DownArrow" GET IF ;
LLOAD(dy) 1.0 + LSTORE(dy) ;
THEN ;
ELSE ;
LLOAD(dy) 0.0 != IF ;
0.0 LSTORE(dx) ;
THEN ;
ELSE ;
ELSE ;
# Check what we're about to hit.
 LLOAD(bgSprites) LLOAD(manY) LLOAD(dy) + GET LLOAD(manX) LLOAD(dx) + GET LSTORE(aheadSprite) ;
LLOAD(aheadSprite) "Picture" GET LSTORE(ahead) ;
# Is it a diamond?
 LLOAD(ahead) LOAD(Rocks_diamondPNG) == IF ;
LLOAD(numDiamonds) 1.0 - LSTORE(numDiamonds) ;
##DUMP numDiamonds DUMP " diamonds left\A/"
 20.0 LSTORE(bgCount) ;
THEN ;
ELSE ;
# Is it a rock?
 LLOAD(ahead) LOAD(Rocks_rockPNG) == IF ;
# Check what we're pushing it into.
 LLOAD(dy) 0.0 == LLOAD(bgSprites) LLOAD(manY) GET LLOAD(manX) 2.0 LLOAD(dx) * + GET "Picture" GET LOAD(Rocks_blankPNG) == AND IF ;
# Push succeeds.
 LLOAD(bgSprites) LLOAD(manY) GET LLOAD(manX) 2.0 LLOAD(dx) * + GET LOAD(Rocks_rockPNG) SET(Picture) THEN ;
# Push fails.
 0.0 LSTORE(dx) ;
0.0 LSTORE(dy) ;
ELSE ;
THEN ;
ELSE ;
# Is it a wall?
 LOAD(Rocks_isWall) TABLE 0 LLOAD(ahead) PUT CALL IF ;
0.0 LSTORE(dx) ;
0.0 LSTORE(dy) ;
THEN ;
ELSE ;
# Does the man move?
 LLOAD(dx) 0.0 != LLOAD(dy) 0.0 != OR IF ;
LLOAD(manX) LLOAD(dx) + LSTORE(manX) ;
LLOAD(manY) LLOAD(dy) + LSTORE(manY) ;
1.0 LSTORE(manCount) ;
# Overwrite the square ahead with a blank.
 LLOAD(aheadSprite) LOAD(Rocks_blankPNG) SET(Picture) # Record the move.
 LLOAD(dx) 0.0 != IF ;
LLOAD(dx) 0.0 < IF ;
"L" LSTORE(key) ;
THEN ;
"R" LSTORE(key) ;
ELSE ;
THEN ;
LLOAD(dy) 0.0 < IF ;
"U" LSTORE(key) ;
THEN ;
"D" LSTORE(key) ;
ELSE ;
ELSE ;
LLOAD(moves) LLOAD(key) + LSTORE(moves) ;
THEN ;
ELSE ;
THEN ;
ELSE ;
# Move the man.
 LLOAD(manCount) 0.0 > IF ;
LLOAD(manCount) 0.25 - LSTORE(manCount) ;
LLOAD(manCount) 0.0 == IF ;
# Stop moving.
 0.0 LSTORE(dx) ;
0.0 LSTORE(dy) ;
THEN ;
ELSE ;
THEN ;
ELSE ;
# Fade the background.
 LLOAD(bgCount) 0.0 > IF ;
LLOAD(bgCount) 1.0 - LSTORE(bgCount) ;
THEN ;
ELSE ;
# Scan for rocks.
 LOAD(Rocks_moveRocks) TABLE 0 LLOAD(manX) PUT 1 LLOAD(manY) PUT 2 LLOAD(dx) PUT 3 LLOAD(dy) PUT 4 LLOAD(bgSprites) PUT CALL KEYS "Escape" GET OR LSTORE(manDead) ;
NEXT ;
ELSE ;
# We've either won or lost.
 WINDOW 0.0 SET(B) TABLE LSTORE(bgSprites) ;
# Helps the garbage collector.
 "Moves made: " DUMP ;
LLOAD(moves) DUMP ;
"\A/" DUMP ;
#  IF demo=="" { dummy = playLevel(map, demo=moves) }
 LLOAD(numDiamonds) 0.0 == IF ;
CLS ;
LLOAD(demo) "" == IF ;
LOAD(Rocks_celebrate) TABLE 0 LOAD(Rocks_diamondPNG) PUT CALL DROPTABLE ;
THEN ;
ELSE ;
TRUE RETURN THEN ;
20.0 FOR DROP LSTORE(i) ;
WINDOW LSTORE(TEMP) ;
LLOAD(TEMP) 0.30000000000000004 RANDOM 0.5 - * LLOAD(TEMP) "X" GET + SET(X) ;
LLOAD(TEMP) 0.30000000000000004 RANDOM 0.5 - * LLOAD(TEMP) "Y" GET + SET(Y) ;
LLOAD(TEMP) TRUE SET(IsVisible) ;
WAIT ;
NEXT ;
ELSE ;
CLS ;
LOAD(Rocks_celebrate) TABLE 0 LOAD(Rocks_rockPNG) PUT CALL DROPTABLE ;
FALSE RETURN ELSE ;
TABLE RETURN 